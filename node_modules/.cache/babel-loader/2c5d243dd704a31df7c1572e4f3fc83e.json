{"ast":null,"code":"import _regeneratorRuntime from \"/Users/javiercosio/Documents/ITC/tweet-react-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/javiercosio/Documents/ITC/tweet-react-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { promisify } from 'util';\nimport crypto from 'crypto';\nvar randomBytesAsync = promisify(crypto.randomBytes);\nvar urlSafeCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~'.split('');\nvar numericCharacters = '0123456789'.split('');\nvar distinguishableCharacters = 'CDEHKMPRTUWXY012458'.split('');\nvar asciiPrintableCharacters = '!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'.split('');\nvar alphanumericCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');\n\nvar generateForCustomCharacters = function generateForCustomCharacters(length, characters) {\n  // Generating entropy is faster than complex math operations, so we use the simplest way\n  var characterCount = characters.length;\n  var maxValidSelector = Math.floor(0x10000 / characterCount) * characterCount - 1; // Using values above this will ruin distribution when using modular division\n\n  var entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n\n  var string = '';\n  var stringLength = 0;\n\n  while (stringLength < length) {\n    // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n    var entropy = crypto.randomBytes(entropyLength);\n    var entropyPosition = 0;\n\n    while (entropyPosition < entropyLength && stringLength < length) {\n      var entropyValue = entropy.readUInt16LE(entropyPosition);\n      entropyPosition += 2;\n\n      if (entropyValue > maxValidSelector) {\n        // Skip values which will ruin distribution when using modular division\n        continue;\n      }\n\n      string += characters[entropyValue % characterCount];\n      stringLength++;\n    }\n  }\n\n  return string;\n};\n\nvar generateForCustomCharactersAsync = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(length, characters) {\n    var characterCount, maxValidSelector, entropyLength, string, stringLength, entropy, entropyPosition, entropyValue;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Generating entropy is faster than complex math operations, so we use the simplest way\n            characterCount = characters.length;\n            maxValidSelector = Math.floor(0x10000 / characterCount) * characterCount - 1; // Using values above this will ruin distribution when using modular division\n\n            entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n\n            string = '';\n            stringLength = 0;\n\n          case 5:\n            if (!(stringLength < length)) {\n              _context.next = 21;\n              break;\n            }\n\n            _context.next = 8;\n            return randomBytesAsync(entropyLength);\n\n          case 8:\n            entropy = _context.sent;\n            // eslint-disable-line no-await-in-loop\n            entropyPosition = 0;\n\n          case 10:\n            if (!(entropyPosition < entropyLength && stringLength < length)) {\n              _context.next = 19;\n              break;\n            }\n\n            entropyValue = entropy.readUInt16LE(entropyPosition);\n            entropyPosition += 2;\n\n            if (!(entropyValue > maxValidSelector)) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 10);\n\n          case 15:\n            string += characters[entropyValue % characterCount];\n            stringLength++;\n            _context.next = 10;\n            break;\n\n          case 19:\n            _context.next = 5;\n            break;\n\n          case 21:\n            return _context.abrupt(\"return\", string);\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function generateForCustomCharactersAsync(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar generateRandomBytes = function generateRandomBytes(byteLength, type, length) {\n  return crypto.randomBytes(byteLength).toString(type).slice(0, length);\n};\n\nvar generateRandomBytesAsync = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(byteLength, type, length) {\n    var buffer;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return randomBytesAsync(byteLength);\n\n          case 2:\n            buffer = _context2.sent;\n            return _context2.abrupt(\"return\", buffer.toString(type).slice(0, length));\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function generateRandomBytesAsync(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar allowedTypes = new Set([undefined, 'hex', 'base64', 'url-safe', 'numeric', 'distinguishable', 'ascii-printable', 'alphanumeric']);\n\nvar createGenerator = function createGenerator(generateForCustomCharacters, generateRandomBytes) {\n  return function (_ref3) {\n    var length = _ref3.length,\n        type = _ref3.type,\n        characters = _ref3.characters;\n\n    if (!(length >= 0 && Number.isFinite(length))) {\n      throw new TypeError('Expected a `length` to be a non-negative finite number');\n    }\n\n    if (type !== undefined && characters !== undefined) {\n      throw new TypeError('Expected either `type` or `characters`');\n    }\n\n    if (characters !== undefined && typeof characters !== 'string') {\n      throw new TypeError('Expected `characters` to be string');\n    }\n\n    if (!allowedTypes.has(type)) {\n      throw new TypeError(\"Unknown type: \".concat(type));\n    }\n\n    if (type === undefined && characters === undefined) {\n      type = 'hex';\n    }\n\n    if (type === 'hex' || type === undefined && characters === undefined) {\n      return generateRandomBytes(Math.ceil(length * 0.5), 'hex', length); // Need 0.5 byte entropy per character\n    }\n\n    if (type === 'base64') {\n      return generateRandomBytes(Math.ceil(length * 0.75), 'base64', length); // Need 0.75 byte of entropy per character\n    }\n\n    if (type === 'url-safe') {\n      return generateForCustomCharacters(length, urlSafeCharacters);\n    }\n\n    if (type === 'numeric') {\n      return generateForCustomCharacters(length, numericCharacters);\n    }\n\n    if (type === 'distinguishable') {\n      return generateForCustomCharacters(length, distinguishableCharacters);\n    }\n\n    if (type === 'ascii-printable') {\n      return generateForCustomCharacters(length, asciiPrintableCharacters);\n    }\n\n    if (type === 'alphanumeric') {\n      return generateForCustomCharacters(length, alphanumericCharacters);\n    }\n\n    if (characters.length === 0) {\n      throw new TypeError('Expected `characters` string length to be greater than or equal to 1');\n    }\n\n    if (characters.length > 0x10000) {\n      throw new TypeError('Expected `characters` string length to be less or equal to 65536');\n    }\n\n    return generateForCustomCharacters(length, characters.split(''));\n  };\n};\n\nvar cryptoRandomString = createGenerator(generateForCustomCharacters, generateRandomBytes);\ncryptoRandomString.async = createGenerator(generateForCustomCharactersAsync, generateRandomBytesAsync);\nexport default cryptoRandomString;","map":{"version":3,"sources":["/Users/javiercosio/Documents/ITC/tweet-react-project/node_modules/crypto-random-string/index.js"],"names":["promisify","crypto","randomBytesAsync","randomBytes","urlSafeCharacters","split","numericCharacters","distinguishableCharacters","asciiPrintableCharacters","alphanumericCharacters","generateForCustomCharacters","length","characters","characterCount","maxValidSelector","Math","floor","entropyLength","ceil","string","stringLength","entropy","entropyPosition","entropyValue","readUInt16LE","generateForCustomCharactersAsync","generateRandomBytes","byteLength","type","toString","slice","generateRandomBytesAsync","buffer","allowedTypes","Set","undefined","createGenerator","Number","isFinite","TypeError","has","cryptoRandomString","async"],"mappings":"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","sourcesContent":["import {promisify} from 'util';\nimport crypto from 'crypto';\n\nconst randomBytesAsync = promisify(crypto.randomBytes);\n\nconst urlSafeCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~'.split('');\nconst numericCharacters = '0123456789'.split('');\nconst distinguishableCharacters = 'CDEHKMPRTUWXY012458'.split('');\nconst asciiPrintableCharacters = '!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'.split('');\nconst alphanumericCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');\n\nconst generateForCustomCharacters = (length, characters) => {\n\t// Generating entropy is faster than complex math operations, so we use the simplest way\n\tconst characterCount = characters.length;\n\tconst maxValidSelector = (Math.floor(0x10000 / characterCount) * characterCount) - 1; // Using values above this will ruin distribution when using modular division\n\tconst entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n\tlet string = '';\n\tlet stringLength = 0;\n\n\twhile (stringLength < length) { // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n\t\tconst entropy = crypto.randomBytes(entropyLength);\n\t\tlet entropyPosition = 0;\n\n\t\twhile (entropyPosition < entropyLength && stringLength < length) {\n\t\t\tconst entropyValue = entropy.readUInt16LE(entropyPosition);\n\t\t\tentropyPosition += 2;\n\t\t\tif (entropyValue > maxValidSelector) { // Skip values which will ruin distribution when using modular division\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstring += characters[entropyValue % characterCount];\n\t\t\tstringLength++;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst generateForCustomCharactersAsync = async (length, characters) => {\n\t// Generating entropy is faster than complex math operations, so we use the simplest way\n\tconst characterCount = characters.length;\n\tconst maxValidSelector = (Math.floor(0x10000 / characterCount) * characterCount) - 1; // Using values above this will ruin distribution when using modular division\n\tconst entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n\tlet string = '';\n\tlet stringLength = 0;\n\n\twhile (stringLength < length) { // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n\t\tconst entropy = await randomBytesAsync(entropyLength); // eslint-disable-line no-await-in-loop\n\t\tlet entropyPosition = 0;\n\n\t\twhile (entropyPosition < entropyLength && stringLength < length) {\n\t\t\tconst entropyValue = entropy.readUInt16LE(entropyPosition);\n\t\t\tentropyPosition += 2;\n\t\t\tif (entropyValue > maxValidSelector) { // Skip values which will ruin distribution when using modular division\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstring += characters[entropyValue % characterCount];\n\t\t\tstringLength++;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst generateRandomBytes = (byteLength, type, length) => crypto.randomBytes(byteLength).toString(type).slice(0, length);\n\nconst generateRandomBytesAsync = async (byteLength, type, length) => {\n\tconst buffer = await randomBytesAsync(byteLength);\n\treturn buffer.toString(type).slice(0, length);\n};\n\nconst allowedTypes = new Set([\n\tundefined,\n\t'hex',\n\t'base64',\n\t'url-safe',\n\t'numeric',\n\t'distinguishable',\n\t'ascii-printable',\n\t'alphanumeric'\n]);\n\nconst createGenerator = (generateForCustomCharacters, generateRandomBytes) => ({length, type, characters}) => {\n\tif (!(length >= 0 && Number.isFinite(length))) {\n\t\tthrow new TypeError('Expected a `length` to be a non-negative finite number');\n\t}\n\n\tif (type !== undefined && characters !== undefined) {\n\t\tthrow new TypeError('Expected either `type` or `characters`');\n\t}\n\n\tif (characters !== undefined && typeof characters !== 'string') {\n\t\tthrow new TypeError('Expected `characters` to be string');\n\t}\n\n\tif (!allowedTypes.has(type)) {\n\t\tthrow new TypeError(`Unknown type: ${type}`);\n\t}\n\n\tif (type === undefined && characters === undefined) {\n\t\ttype = 'hex';\n\t}\n\n\tif (type === 'hex' || (type === undefined && characters === undefined)) {\n\t\treturn generateRandomBytes(Math.ceil(length * 0.5), 'hex', length); // Need 0.5 byte entropy per character\n\t}\n\n\tif (type === 'base64') {\n\t\treturn generateRandomBytes(Math.ceil(length * 0.75), 'base64', length); // Need 0.75 byte of entropy per character\n\t}\n\n\tif (type === 'url-safe') {\n\t\treturn generateForCustomCharacters(length, urlSafeCharacters);\n\t}\n\n\tif (type === 'numeric') {\n\t\treturn generateForCustomCharacters(length, numericCharacters);\n\t}\n\n\tif (type === 'distinguishable') {\n\t\treturn generateForCustomCharacters(length, distinguishableCharacters);\n\t}\n\n\tif (type === 'ascii-printable') {\n\t\treturn generateForCustomCharacters(length, asciiPrintableCharacters);\n\t}\n\n\tif (type === 'alphanumeric') {\n\t\treturn generateForCustomCharacters(length, alphanumericCharacters);\n\t}\n\n\tif (characters.length === 0) {\n\t\tthrow new TypeError('Expected `characters` string length to be greater than or equal to 1');\n\t}\n\n\tif (characters.length > 0x10000) {\n\t\tthrow new TypeError('Expected `characters` string length to be less or equal to 65536');\n\t}\n\n\treturn generateForCustomCharacters(length, characters.split(''));\n};\n\nconst cryptoRandomString = createGenerator(generateForCustomCharacters, generateRandomBytes);\n\ncryptoRandomString.async = createGenerator(generateForCustomCharactersAsync, generateRandomBytesAsync);\n\nexport default cryptoRandomString;\n"]},"metadata":{},"sourceType":"module"}