{"ast":null,"code":"import { promisify } from 'util';\nimport crypto from 'crypto';\nconst randomBytesAsync = promisify(crypto.randomBytes);\nconst urlSafeCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~'.split('');\nconst numericCharacters = '0123456789'.split('');\nconst distinguishableCharacters = 'CDEHKMPRTUWXY012458'.split('');\nconst asciiPrintableCharacters = '!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'.split('');\nconst alphanumericCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');\n\nconst generateForCustomCharacters = (length, characters) => {\n  // Generating entropy is faster than complex math operations, so we use the simplest way\n  const characterCount = characters.length;\n  const maxValidSelector = Math.floor(0x10000 / characterCount) * characterCount - 1; // Using values above this will ruin distribution when using modular division\n\n  const entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n\n  let string = '';\n  let stringLength = 0;\n\n  while (stringLength < length) {\n    // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n    const entropy = crypto.randomBytes(entropyLength);\n    let entropyPosition = 0;\n\n    while (entropyPosition < entropyLength && stringLength < length) {\n      const entropyValue = entropy.readUInt16LE(entropyPosition);\n      entropyPosition += 2;\n\n      if (entropyValue > maxValidSelector) {\n        // Skip values which will ruin distribution when using modular division\n        continue;\n      }\n\n      string += characters[entropyValue % characterCount];\n      stringLength++;\n    }\n  }\n\n  return string;\n};\n\nconst generateForCustomCharactersAsync = async (length, characters) => {\n  // Generating entropy is faster than complex math operations, so we use the simplest way\n  const characterCount = characters.length;\n  const maxValidSelector = Math.floor(0x10000 / characterCount) * characterCount - 1; // Using values above this will ruin distribution when using modular division\n\n  const entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n\n  let string = '';\n  let stringLength = 0;\n\n  while (stringLength < length) {\n    // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n    const entropy = await randomBytesAsync(entropyLength); // eslint-disable-line no-await-in-loop\n\n    let entropyPosition = 0;\n\n    while (entropyPosition < entropyLength && stringLength < length) {\n      const entropyValue = entropy.readUInt16LE(entropyPosition);\n      entropyPosition += 2;\n\n      if (entropyValue > maxValidSelector) {\n        // Skip values which will ruin distribution when using modular division\n        continue;\n      }\n\n      string += characters[entropyValue % characterCount];\n      stringLength++;\n    }\n  }\n\n  return string;\n};\n\nconst generateRandomBytes = (byteLength, type, length) => crypto.randomBytes(byteLength).toString(type).slice(0, length);\n\nconst generateRandomBytesAsync = async (byteLength, type, length) => {\n  const buffer = await randomBytesAsync(byteLength);\n  return buffer.toString(type).slice(0, length);\n};\n\nconst allowedTypes = new Set([undefined, 'hex', 'base64', 'url-safe', 'numeric', 'distinguishable', 'ascii-printable', 'alphanumeric']);\n\nconst createGenerator = (generateForCustomCharacters, generateRandomBytes) => ({\n  length,\n  type,\n  characters\n}) => {\n  if (!(length >= 0 && Number.isFinite(length))) {\n    throw new TypeError('Expected a `length` to be a non-negative finite number');\n  }\n\n  if (type !== undefined && characters !== undefined) {\n    throw new TypeError('Expected either `type` or `characters`');\n  }\n\n  if (characters !== undefined && typeof characters !== 'string') {\n    throw new TypeError('Expected `characters` to be string');\n  }\n\n  if (!allowedTypes.has(type)) {\n    throw new TypeError(`Unknown type: ${type}`);\n  }\n\n  if (type === undefined && characters === undefined) {\n    type = 'hex';\n  }\n\n  if (type === 'hex' || type === undefined && characters === undefined) {\n    return generateRandomBytes(Math.ceil(length * 0.5), 'hex', length); // Need 0.5 byte entropy per character\n  }\n\n  if (type === 'base64') {\n    return generateRandomBytes(Math.ceil(length * 0.75), 'base64', length); // Need 0.75 byte of entropy per character\n  }\n\n  if (type === 'url-safe') {\n    return generateForCustomCharacters(length, urlSafeCharacters);\n  }\n\n  if (type === 'numeric') {\n    return generateForCustomCharacters(length, numericCharacters);\n  }\n\n  if (type === 'distinguishable') {\n    return generateForCustomCharacters(length, distinguishableCharacters);\n  }\n\n  if (type === 'ascii-printable') {\n    return generateForCustomCharacters(length, asciiPrintableCharacters);\n  }\n\n  if (type === 'alphanumeric') {\n    return generateForCustomCharacters(length, alphanumericCharacters);\n  }\n\n  if (characters.length === 0) {\n    throw new TypeError('Expected `characters` string length to be greater than or equal to 1');\n  }\n\n  if (characters.length > 0x10000) {\n    throw new TypeError('Expected `characters` string length to be less or equal to 65536');\n  }\n\n  return generateForCustomCharacters(length, characters.split(''));\n};\n\nconst cryptoRandomString = createGenerator(generateForCustomCharacters, generateRandomBytes);\ncryptoRandomString.async = createGenerator(generateForCustomCharactersAsync, generateRandomBytesAsync);\nexport default cryptoRandomString;","map":{"version":3,"sources":["/Users/javiercosio/Documents/ITC/tweet-react-project/node_modules/crypto-random-string/index.js"],"names":["promisify","crypto","randomBytesAsync","randomBytes","urlSafeCharacters","split","numericCharacters","distinguishableCharacters","asciiPrintableCharacters","alphanumericCharacters","generateForCustomCharacters","length","characters","characterCount","maxValidSelector","Math","floor","entropyLength","ceil","string","stringLength","entropy","entropyPosition","entropyValue","readUInt16LE","generateForCustomCharactersAsync","generateRandomBytes","byteLength","type","toString","slice","generateRandomBytesAsync","buffer","allowedTypes","Set","undefined","createGenerator","Number","isFinite","TypeError","has","cryptoRandomString","async"],"mappings":"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","sourcesContent":["import {promisify} from 'util';\nimport crypto from 'crypto';\n\nconst randomBytesAsync = promisify(crypto.randomBytes);\n\nconst urlSafeCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~'.split('');\nconst numericCharacters = '0123456789'.split('');\nconst distinguishableCharacters = 'CDEHKMPRTUWXY012458'.split('');\nconst asciiPrintableCharacters = '!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'.split('');\nconst alphanumericCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');\n\nconst generateForCustomCharacters = (length, characters) => {\n\t// Generating entropy is faster than complex math operations, so we use the simplest way\n\tconst characterCount = characters.length;\n\tconst maxValidSelector = (Math.floor(0x10000 / characterCount) * characterCount) - 1; // Using values above this will ruin distribution when using modular division\n\tconst entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n\tlet string = '';\n\tlet stringLength = 0;\n\n\twhile (stringLength < length) { // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n\t\tconst entropy = crypto.randomBytes(entropyLength);\n\t\tlet entropyPosition = 0;\n\n\t\twhile (entropyPosition < entropyLength && stringLength < length) {\n\t\t\tconst entropyValue = entropy.readUInt16LE(entropyPosition);\n\t\t\tentropyPosition += 2;\n\t\t\tif (entropyValue > maxValidSelector) { // Skip values which will ruin distribution when using modular division\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstring += characters[entropyValue % characterCount];\n\t\t\tstringLength++;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst generateForCustomCharactersAsync = async (length, characters) => {\n\t// Generating entropy is faster than complex math operations, so we use the simplest way\n\tconst characterCount = characters.length;\n\tconst maxValidSelector = (Math.floor(0x10000 / characterCount) * characterCount) - 1; // Using values above this will ruin distribution when using modular division\n\tconst entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n\tlet string = '';\n\tlet stringLength = 0;\n\n\twhile (stringLength < length) { // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n\t\tconst entropy = await randomBytesAsync(entropyLength); // eslint-disable-line no-await-in-loop\n\t\tlet entropyPosition = 0;\n\n\t\twhile (entropyPosition < entropyLength && stringLength < length) {\n\t\t\tconst entropyValue = entropy.readUInt16LE(entropyPosition);\n\t\t\tentropyPosition += 2;\n\t\t\tif (entropyValue > maxValidSelector) { // Skip values which will ruin distribution when using modular division\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstring += characters[entropyValue % characterCount];\n\t\t\tstringLength++;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst generateRandomBytes = (byteLength, type, length) => crypto.randomBytes(byteLength).toString(type).slice(0, length);\n\nconst generateRandomBytesAsync = async (byteLength, type, length) => {\n\tconst buffer = await randomBytesAsync(byteLength);\n\treturn buffer.toString(type).slice(0, length);\n};\n\nconst allowedTypes = new Set([\n\tundefined,\n\t'hex',\n\t'base64',\n\t'url-safe',\n\t'numeric',\n\t'distinguishable',\n\t'ascii-printable',\n\t'alphanumeric'\n]);\n\nconst createGenerator = (generateForCustomCharacters, generateRandomBytes) => ({length, type, characters}) => {\n\tif (!(length >= 0 && Number.isFinite(length))) {\n\t\tthrow new TypeError('Expected a `length` to be a non-negative finite number');\n\t}\n\n\tif (type !== undefined && characters !== undefined) {\n\t\tthrow new TypeError('Expected either `type` or `characters`');\n\t}\n\n\tif (characters !== undefined && typeof characters !== 'string') {\n\t\tthrow new TypeError('Expected `characters` to be string');\n\t}\n\n\tif (!allowedTypes.has(type)) {\n\t\tthrow new TypeError(`Unknown type: ${type}`);\n\t}\n\n\tif (type === undefined && characters === undefined) {\n\t\ttype = 'hex';\n\t}\n\n\tif (type === 'hex' || (type === undefined && characters === undefined)) {\n\t\treturn generateRandomBytes(Math.ceil(length * 0.5), 'hex', length); // Need 0.5 byte entropy per character\n\t}\n\n\tif (type === 'base64') {\n\t\treturn generateRandomBytes(Math.ceil(length * 0.75), 'base64', length); // Need 0.75 byte of entropy per character\n\t}\n\n\tif (type === 'url-safe') {\n\t\treturn generateForCustomCharacters(length, urlSafeCharacters);\n\t}\n\n\tif (type === 'numeric') {\n\t\treturn generateForCustomCharacters(length, numericCharacters);\n\t}\n\n\tif (type === 'distinguishable') {\n\t\treturn generateForCustomCharacters(length, distinguishableCharacters);\n\t}\n\n\tif (type === 'ascii-printable') {\n\t\treturn generateForCustomCharacters(length, asciiPrintableCharacters);\n\t}\n\n\tif (type === 'alphanumeric') {\n\t\treturn generateForCustomCharacters(length, alphanumericCharacters);\n\t}\n\n\tif (characters.length === 0) {\n\t\tthrow new TypeError('Expected `characters` string length to be greater than or equal to 1');\n\t}\n\n\tif (characters.length > 0x10000) {\n\t\tthrow new TypeError('Expected `characters` string length to be less or equal to 65536');\n\t}\n\n\treturn generateForCustomCharacters(length, characters.split(''));\n};\n\nconst cryptoRandomString = createGenerator(generateForCustomCharacters, generateRandomBytes);\n\ncryptoRandomString.async = createGenerator(generateForCustomCharactersAsync, generateRandomBytesAsync);\n\nexport default cryptoRandomString;\n"]},"metadata":{},"sourceType":"module"}